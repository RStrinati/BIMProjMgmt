# Frontend Performance: Proposed Lightweight Project & Timeline Endpoints

## 1. Summary
- Existing `/api/projects`, `/api/project_review_statistics`, and `/api/dashboard/timeline` endpoints return large, denormalised payloads.
- The React UI currently downloads and filters many megabytes per view, leading to slow initial renders and unnecessary network strain.
- Introducing dedicated lightweight endpoints with pagination, server-side filtering, and pre-aggregated metrics will unblock further frontend optimisations and improve perceived performance.

## 2. Current Usage Snapshot
| View | Endpoint(s) | Pain Points |
| --- | --- | --- |
| Projects list (`ProjectsPage.tsx`) | `/projects`, `/projects/stats`, `/project_review_statistics`, `/users` | `/projects` returns full project records (addresses, descriptions, folder paths, etc.) even when only summary cards + list metadata are required. Review stats fetched separately and joined client-side. No server pagination/filtering. |
| Dashboard timeline (`DashboardPage.tsx`, `DashboardTimelineChart.tsx`) | `/dashboard/timeline` | Returns every project + nested review items for the last 12 months. Payload grows with portfolio size; client iterates O(projects × reviews × tick-marks). No way to request minimal fields or window beyond `months` parameter. |
| Cross-view dropdowns (Projects filter chips, Data Imports project selector, etc.) | `/projects` (re-used) | Consumers just need `id`, `name`, `number`, `status` but pay cost of full project object. |

## 3. Proposed Backend Additions

### 3.1 `/projects/summary`
Returns paginated, filterable project metadata tailored for list views.

**Query Params**
- `page`, `page_size` (default 1/25, max 100)
- `search` (matches name/number/client)
- `status`, `type_id`, `client_id`, `manager_id`
- `sort` (one of `created_at`, `updated_at`, `name`, `status`)

**Response (200)**
```jsonc
{
  "items": [
    {
      "project_id": 42,
      "project_name": "Solar Farm West",
      "project_number": "SF-102",
      "status": "Active",
      "priority": "High",
      "client_name": "Renewables Co",
      "project_type": "Solar",
      "internal_lead": 7,
      "total_services": 12,
      "agreed_fee_total": 1234500,
      "billed_amount_total": 845000,
      "upcoming_reviews_30_days": 3,
      "updated_at": "2025-10-24T12:21:00Z"
    }
  ],
  "page": 1,
  "page_size": 25,
  "total": 187,
  "aggregates": {
    "total_projects": 187,
    "active_projects": 92,
    "completed_projects": 41,
    "on_hold_projects": 8
  }
}
```

**Benefits**
- Single request replaces `/projects` + `/projects/stats` + `/project_review_statistics` for list view.
- Aggregates can drive dashboard cards without extra fetches.
- Smaller payload enables immediate rendering and faster client-side search.

### 3.2 `/projects/options`
Minimal dataset for dropdowns and autocomplete.

**Response**
```jsonc
{
  "items": [
    { "project_id": 42, "label": "SF-102 — Solar Farm West", "status": "Active" }
  ],
  "generated_at": "2025-10-27T08:10:00Z"
}
```
- Support optional query params `status`, `search`, `limit` (default 20) for autocomplete.
- Cache aggressively (ETag/Last-Modified) since it’s used in multiple views.

### 3.3 `/dashboard/timeline/summary`
Focused timeline data with pre-aggregated bins.

**Query Params**
- `window` (e.g., `P6M`, `P12M`)
- `manager_id`, `client_id`, `project_type`, `status`
- `include_reviews` boolean (default false) → when false, return aggregated counts instead of all review items.

**Response when `include_reviews=false`**
```jsonc
{
  "projects": [
    {
      "project_id": 42,
      "project_name": "Solar Farm West",
      "project_manager": "Alex Smith",
      "client_name": "Renewables Co",
      "project_type": "Solar",
      "start_date": "2024-02-01",
      "end_date": "2025-11-30",
      "review_counts": {
        "planned": 4,
        "in_progress": 1,
        "completed": 6,
        "overdue": 0
      },
      "next_review_date": "2025-01-12"
    }
  ],
  "window": { "start": "2024-11-01", "end": "2025-10-31" },
  "generated_at": "2025-10-27T08:20:00Z"
}
```

**Response when `include_reviews=true`**
- Allow optional `max_reviews_per_project` (default 50) and server-side filtering (`status`, `from`, `to`) to cap payload size.

### 3.4 Versioning & Backwards Compatibility
- New endpoints can launch alongside existing ones; frontend can progressively adopt.
- Once clients migrate, mark legacy endpoints as deprecated and document timeline for retirement.

## 4. Backend Implementation Considerations
1. **Database Views/Materialized Tables**  
   - Consider precomputing aggregates (service counts, billing totals, review stats) for `/projects/summary` to avoid N+1 queries.
2. **Caching**  
   - Timeline summary may be cached per filter set for a short TTL (e.g., 5 min) to avoid heavy recalculations.
3. **Authentication/Authorisation**  
   - Ensure new endpoints respect existing project-level permissions (e.g., only return projects the user can view).
4. **Error Handling**  
   - Follow existing API error contract; provide validation errors for unsupported filters/sorts.
5. **Monitoring**  
   - Emit metrics for request counts, median/95th percentile response times to validate performance gains.

## 5. Frontend Adoption Plan
1. **Prototype** against mocked responses to ensure UI components handle the new structures (especially aggregates & pagination metadata).
2. **Feature Flag** to toggle between legacy and new endpoints during rollout.
3. **Regression Tests** verifying that list filtering, timeline interactions, and dropdowns behave identically with new data sources.
4. **Perf Measurement** using the existing `printPerfSummary` and `printPerfDelta` helpers before/after switching endpoints.

## 6. Open Questions for Backend
- Do we need additional filters (e.g., cost centre, geographic region) for `/projects/summary`?
- Should `/dashboard/timeline/summary` support grouping (e.g., by month) to drive future visualisations?
- What SLA or freshness requirements exist for aggregated billing/review stats?

## 7. Next Steps
1. Review proposal with backend team; refine parameter names or payload shapes.
2. Align on implementation timeline and versioning strategy.
3. Update API documentation (OpenAPI/Swagger) once endpoints are agreed.
4. Schedule frontend integration tasks post-backend delivery.


